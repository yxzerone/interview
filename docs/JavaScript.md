# JavaScript

## 原型及原型链

在 JavaScript 中，可以使用构造函数新建一个对象。每一个构造函数上都有一个 `prototype` 属性，它是构造函数创建实例的原型，用于存储实例共享的属性和方法。

在现代浏览器中，对象上都实现了 `__proto__` 属性。通过它，可以访问对象的原型。但是不推荐以这种形式访问原型，因为这种方式并没有在规范中定义。

ES6 新增了一个 Object.getPrototypeof 方法，可以通过这个方法来获取对象的原型。

访问一个对象的属性时，如果对象自身不存在这个属性，那么 JavaScript 就会继续搜寻它的原型对象。而原型对象又有原型，如果这样一直搜寻下去，就会发现这是一条链路，也就是原型链。

原型链上的所有原型都是对象，由构造函数 Object 创建。不妨说，通常情况下，在 JavaScript 中，所有的对象都是由构造函数 Object 创建，所有对象都可以访问 Object.prototype 上的属性和方法。因此，原型链的终点就是 Object.prototype。但是 Object.prototype 的原型也是存在的，它是 `null`。

## 闭包

闭包指有权访问另一个函数作用域的函数。创建闭包最常见的方式就是在函数作用域下创建新函数，创建的函数可以访问当前函数作用域下的局部变量。

用途：

1. 创建闭包，并返回函数作用域内部创建的函数，可以使函数外部间接访问函数内部的变量。通过这种方式，可以创建私有变量。

2. 留存函数作用域下的局部变量。因为函数作用域内部创建的函数保留了部分变量的引用，所以只要这个函数不被回收，变量就不被回收。

## 垃圾回收

在 JavaScript 运行时，需要分配空间储存变量。当变量不在参与运行时，或者当某个值不在被变量所引用时，JavaScript 引擎就会自动收回被占用的内存空间，这就是垃圾回收。

JavaScript 中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续到页面卸载。而局部变量通常情况下，声明在块作用域，或者函数作用域下。因此，局部变量的生命周期从作用域执行代码开始，直到作用域的代码片段执行结束。在这个过程中，局部变量会在堆或栈中存储，当作用域的代码片段执行结束后，这些局部变量不再被使用，它们所占用的空间就会被释放。

不过，当局部变量在作用域结束后依然被使用时（比如闭包），它们不会被回收。

浏览器通常使用的垃圾回收方法有两种：标记清除，引用计数。

1. 标记清除。当变量进入执行环境时，就标记这个变量“进入环境”。被标记“进入环境”的变量是不能被回收的，因为它们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被释放内存。

2. 引用计数。引用计数是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型的值赋值给该变量时，该值的引用次数就会加一。相反，如果将这个变量指向另外一个值时，则之前值的引用次数就减一。当一个值的引用次数为 0 时，说明这个值不在具备价值。因此，在下次回收机制再运行时，这个变量就会被释放内存。

虽然 JavaScript 引擎可以自动回收垃圾，但是当代码较为复杂时，垃圾回收所带来的代价比较大，所以应该尽可能地减少垃圾回收。

- **对数组进行优化：**在清空一个数组时，最简单的方法就是给其赋值为 []，但是这同时会创建一个新数组。可以通过将数组的长度设为 0，以此来达到清空数组的目的。

- **对对象进行优化：**对象尽可能复用，对于不在使用的对象，应该尽快将其设置为 null，加快回收。

- **对函数进行优化：**在循环中的函数表达式，尽量将其放在函数的外面，提高复用。

## 内存泄露

- **意外的全局变量：**由于使用未声明的变量，意外创建了一个全局变量，而使得其一直留在内存中无法被回收。

- **被遗忘的计时器或回调函数：**设置了 setInterval 定时器，却忘记取消。如果循环函数有引用外部变量时，则变量将一直留在内存中，无法被回收。

- **脱离 DOM 的引用：**对一个变量赋值了一个 DOM 元素的引用，如果之后这个 DOM 元素被移除，因为有变量一直保留了这个元素的引用，所以这个 DOM 元素无法及时被回收。

- **闭包：**不合理的闭包使用，会导致一些变量一直留在内存中，无法被释放。
